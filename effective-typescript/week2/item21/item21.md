### 타입 넓히기

타입스크립트가 작성된 코드를 체크하는 **정적 분석** 시점에
변수는 가능한 값들의 집합인 타입을 가진다.

상수를 사용해서 변수를 초기화할 때 타입을 명시하지 않더라도 타입 체커는 타입을 결정해야 한다.
즉, **지정된 단일 값**을 가지고 **할당 가능한 값들의 집합을 유추**해야 한다는 뜻이며
이러한 과정을 넓히기(widening)이라고 부른다.

> 지정된 단일 값이 가질 수 있는 타입들을 유추하는 과정을 넓히기라고 한다.

타입스크립트가 작성자의 의도를 유추할뿐이지 정확한 타입을 제공하는 것이 아니므로
넓히기의 과정을 제어할 수 있게 몇가지 방법을 제공한다

1. const

=> 너무나 당연한 말이지만 let 대신 const로 변수를 선언하면 더 좁은 타입이 된다.

다만 const는 만능이 아니며 객체와 배열의 경우에는 여전히 문제가 존재한다.

배열과 객체는 참조값이므로 여전히 요소들에 대한 타입을 명확히 지정할 수 없다. 

즉 객체나 배열의 경우 타입스크립트의 넓히기 알고리즘은 각 요소를 let으로 할당된 것처럼 다룬다.

예시 2번을 통해 확인해보자.

예시 2번의 x 속성의 가장 구체적인 경우 `{ readonly x: 1}`이다.
조금 추상적으로는 `{ x: number }`이고, 가장 추상적이라면 `{[key: string] : number}`가 된다.

위에 언급한 바와 같이 객체의 각 요소를 let으로 초기화 한 것과 같이 다룬다.(예제 3)
그래서 `{ x: number }`의 타입을 갖는 것이며 타입 캐스팅이 불가능하며 해당 객체에 다른 속성을 추가하지도 못한다.
(이말은 자바스크립트를 사용하는 것과 같이 이미 만들어진 객체에 프로퍼티를 추가하는 것이 아닌 객체를 한번에 만들어야 한다. )
___

타입 추론의 강도를 직접 제어하려면 타입스크립트의 기본 동작을 재정의 해야 하는데 3가지 방법이 있다.

1. 명시적 타입 구문을 제공한다.
  - 말 그대로 변수에 타입을 명시적으로 제공한다.
2. 타입 체커테 추가적인 문맥을 제공한다.
  - 예를 들어 함수의 매개변수로 값을 전달하는 방법이 있다.
3. const 단언문을 사용한다.
  - const 단언문과 변수 선언에 쓰이는 let,const와 혼동해서는 안된다
  const 단언문은 온전히 타입 공간의 기법이다.
  예제 4번을 통해 각 변수에 추론된 타입을 살펴보자.

값 뒤에 `as const` 를 작성하면 타입스크립트는 최대한 좁은 타입으로 추론한다.
변수 v3에는 넓히기가 동작하지 않았다.
변수 v3이 진짜 상수라면 주석에 보이는 추론된 타입이 실제로 원하는 형태일 것이다.
또한 배열을 튜플 타입으로 추론할 때에도 `as const`를 사용할 수 있다.